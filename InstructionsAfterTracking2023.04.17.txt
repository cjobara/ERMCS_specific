
Folder should have in it to start:

MaxInt/
	contains RGB files named *filebase* + '_3_MaxInt_RGB.tif'


Tracks.mat
	contains vector-processed trajectories


Optional but a good idea:

ER/
Mito/
Maps/
	contains output from JBM analysis (if you have it)


Then run the following in order:

Matlab function "DensityVisualization"   -inputs (Tracks, 30, true)
Run a for loop and call matlab function "LocDensityFigIntUse"   -inputs (Tracks,i,30)
Matlab script "QuickTrackPlotter.m" (adjust size for loop to match size of Tracks)
Fiji macro "CustomMaskMaker" (No need to be exact, it's just to visualize later)

Three Fiji macro scripts in a row:

CSidentifier (on all files)
CSchecker (on all files)
CSrepairer (on any with mistakes)

Run Matlab script "ContactSiteMapper.m" in parent directory (if JBM data is available). If not, use "ContactSiteMapperNoDeff.m".

Run the Matlab scripts "CellAccumulator.m" and "CStabulator.m" in the folder "TrackData/". Copy the outputs to the main directory if you want to keep them.
Use a for loop to store the data in CSindexing.mat as a field in Tracks. The field name should be "MitoCSindex". (The field in CSinfo is called "CSindex").

Change the name of the folder "CSdata/" to "CSsnaps/" and make a new "CSdata/" folder.
Run Matlab script "CSrefiner1.m" or "CSrefiner2.m" depending on if you only want to process the mitoflag-positive CSs (1) or all the CSs (2).
	If you choose 2, make directory "CSsnaps2/" to hold the images of each CS.

Run Matlab script "CSensemble1.m" or "CSensemble2.m" in the condition parent directory depending on whether you want non-mito CSs to count in the cell average Deff (2) or not (1). (Skip this step if there is no Deff). (This pulls out net ensemble data for putting in prism/excel/etc.)

% This step for blinded nonparametric Bayesian analysis (I'm assuming you have scrambled and put through Calderon Python Code and Model Fitting software).
Run function "ChrisSegAssign.m" --inputs (ChrisC, SegmentDetails)
	ChrisC is a structured array in the format it is generated by the NPB software (fields: t,x,y,cp).
	SegmentDetails is a direct table import from the excel files genereated by the NPB python code.

You can manually extract the numbers from any NPB results using ChrisCconvert.m -inputs  (SegmentDetails), but ChrisCSegAssign.m will do this for you automatically and embed in CS.

Run the ChrisCunblinder.m to reassign the NPB results to the correct cell, condition, and trackIDs. -inputs(ChrisC, IndexMatrix)
The resulting structured array is of the standard format "Condition_NPB.mat".

If you want to reassign this info to the Tracks variable, use FinalTrackAssembler.m to update your Track structures.



% Assemble Final CS structures

Run the matlab function CS_builder.m. --inputs (Tracks). This will assemble a proper CS structured array for everything downstream.



% This is an averager based on cartesian coordinates. If things aren't symmetrical, it doesn't work all that well.
Run Matlab script "CS averager.m" which will prepare structured arrays containing all the contact sites in a form the averager can read.
Run Matlab function "AvgAccumulator" to generate figures with the summed CS's and save the output X,Y,and Deff of the centered CS localizations as A,B, and C, repectively.
 -input (CSstructure)  --output [A,B,C] 
	note: A, B, and C are matrices of size (m,n) where m is the number of localizations in the most numerous CS and n is CS index.






% This step for manual designation of entry and exit kinetics 
Run function DwellTimeManual -inputs (CS, [indexes you want]). Output is a binding info structured array that can be directly appended into CS with the next function. You may choose to compile from the backups in the TempFolder using the function AssembleDwellTimesData(CS, TempFolder).
Run function AddDwellTimestoCS -inputs (CS, BindingInfo). (You may need to define a CSindex field, if you haven't done this, yet)
Run function EntryExitManualClassifier (CS, [indexes you want]).
Use TempFileCompiler2.m script to assemble from saved .mat files for each CS if something goes wrong during the process so you don't have to start over.
I'd recommend reordering the fields at the end to group them logically. Use this command:

	UpdatedCS=orderfields(CS, [1:3 26 4 11 22 24 25 5 7 6 10 8 9 12:19 21 23 20]);

Use ExtractBindingInfo.m to create a table of binding statistics that can be exported for Excel/Prism, if you need it. -inputs (CS) 
There is a function "ParseCompleteInteractions" that will generate variables for doing math from the BindingTable.

The function FindEngagedTracksByCell will generate a structured array that is grouped by cell and has information about what proportion of tracks are interacting with CSs or not.




% Final clean up and integration
Once everything is done, you can use the following to integrate the final CS and Tracks variables into one another for ease of indexing:

Run matlab script "AssignCSindexByCell.m" to integrate the two structures (Tracks and CS) together for easy indexing. -inputs(Tracks, CS)
If you want to group the data by cell, use FindEngagedTracksByCell.m. -inputs (Tracks, CS)
